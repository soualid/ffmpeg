// https://tech.ebu.ch/docs/tech/tech3264.pdf

#include <stdbool.h>
#include <libavformat/internal.h>
#include "ass_split.h"
#include "libavcodec/ass.h"
#include "avcodec.h"
#include "codec.h"
#include "codec_internal.h"
#include "libavformat/avformat.h"
#include "libavformat/avio.h"
#include "libavutil/intreadwrite.h"

#define EBU_HEADER_SIZE 1024
#define TTI_BLOCK_SIZE 128
#define TTI_TEXT_FIELD_OFFSET 16
#define TTI_TEXT_FIELD_LENGTH 112

static int ebustl_probe(const AVProbeData *p)
{
    if (p->buf_size < 5)
        return 0;
    if (p->buf[3] == 'S' && p->buf[4] == 'T' && p->buf[5] == 'L')
        return AVPROBE_SCORE_MAX;
    return 0;
}

static int ebustl_read_header(AVFormatContext *s)
{
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return AVERROR(ENOMEM);
    st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;
    st->codecpar->codec_id = AV_CODEC_ID_EBUSTL;
    st->codecpar->width = 720;
    st->codecpar->height = 576;
    st->time_base = (AVRational){1, 1000};
    avpriv_set_pts_info(st, 64, 1, 1000);
    avio_seek(s->pb, EBU_HEADER_SIZE, SEEK_SET);
    return 0;
}

static int64_t ebustl_timestamp_to_pts(const uint8_t *timecode)
{
    int hours = timecode[0];
    int minutes = timecode[1];
    int seconds = timecode[2];
    int frames = timecode[3];
    return ((hours - 10) * 3600LL + minutes * 60LL + seconds) * 1000LL + frames * (1000 / 25);
}

static int ebustl_read_packet(AVFormatContext *s, AVPacket *pkt)
{
    int ret = av_new_packet(pkt, TTI_BLOCK_SIZE);
    if (ret < 0)
        return ret;
    ret = avio_read(s->pb, pkt->data, TTI_BLOCK_SIZE);
    if (ret < TTI_BLOCK_SIZE) {
        av_packet_unref(pkt);
        return AVERROR_EOF;
    }
    int64_t pts = ebustl_timestamp_to_pts(pkt->data + 5);
    pkt->pts = pts;
    int64_t pts_end = ebustl_timestamp_to_pts(pkt->data + 9);
    pkt->duration = pts_end - pts;
    pkt->stream_index = 0;
    return 0;
}

static int ebustl_read_close(AVFormatContext *s)
{
    return 0;
}

AVInputFormat ff_ebustl_demuxer = {
    .name           = "ebustl",
    .long_name      = "EBU STL Subtitle format",
    .extensions     = "stl",
    .read_probe     = ebustl_probe,
    .read_header    = ebustl_read_header,
    .read_packet    = ebustl_read_packet,
    .read_close     = ebustl_read_close,
};

typedef struct {
    AVSubtitleRect **rects;
    int64_t end_timecode;
} EbuStlContext;

static av_cold int ebustl_decode_init(AVCodecContext *avctx)
{
    av_log(avctx, AV_LOG_DEBUG, "Initializing EBU STL decoder\n");
    EbuStlContext *ctx = avctx->priv_data;
    ctx->rects = NULL;
    if (avctx->time_base.num == 0 || avctx->time_base.den == 0) {
        avctx->time_base = (AVRational){1, 1000};
    }
    if (avctx->width <= 0 || avctx->height <= 0) {
        av_log(avctx, AV_LOG_WARNING, "Video dimensions not set in AVCodecContext, setting defaults.\n");
        avctx->width = 720;
        avctx->height = 576;
    }
    const char *header_data =
        "[Script Info]\n"
        "; Script generated by FFmpeg\n"
        "ScriptType: v4.00+\n"
        "PlayResX: 720\n"
        "PlayResY: 576\n"
        "ScaledBorderAndShadow: yes\n"
        "YCbCr Matrix: None\n\n"
        "[V4+ Styles]\n"
        "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n"
        "Style: Default,Arial,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,1,2,10,10,10,1\n\n"
        "[Events]\n"
        "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n";
    int header_size = strlen(header_data) + 1;
    avctx->subtitle_header = av_mallocz(header_size);
    if (!avctx->subtitle_header) {
        av_log(avctx, AV_LOG_ERROR, "Failed to allocate subtitle header buffer\n");
        return AVERROR(ENOMEM);
    }
    memcpy(avctx->subtitle_header, header_data, header_size - 1);
    avctx->subtitle_header[header_size - 1] = '\0';
    avctx->subtitle_header_size = header_size;
    av_log(avctx, AV_LOG_DEBUG, "Subtitle header initialized successfully\n");
    return 0;
}

// Log the hex content of the TTI block for debugging
static void log_tti_block_hex(const uint8_t *buf, int buf_size) {
    char hex_output[TTI_BLOCK_SIZE * 3 + 1];
    int i;
    for (i = 0; i < TTI_BLOCK_SIZE && i < buf_size; i++) {
        snprintf(hex_output + i * 3, 4, "%02X ", buf[i]);
    }
    av_log(NULL, AV_LOG_DEBUG, "TTI Block (hex): %s\n", hex_output);
}

static char* map_iso6937_to_utf8(unsigned char diacritic, char base);

static char* map_iso6937_to_utf8(unsigned char diacritic, char base) {
    typedef struct {
        unsigned char diacritic;
        char base;
        char utf8[4];
    } DiacriticMapping;

    DiacriticMapping mappings[] = {
        {0xC1, 'A', "À"}, {0xC1, 'E', "È"}, {0xC1, 'I', "Ì"}, {0xC1, 'O', "Ò"}, {0xC1, 'U', "Ù"},
        {0xC1, 'a', "à"}, {0xC1, 'e', "è"}, {0xC1, 'i', "ì"}, {0xC1, 'o', "ò"}, {0xC1, 'u', "ù"},
        {0xC2, 'A', "Á"}, {0xC2, 'E', "É"}, {0xC2, 'I', "Í"}, {0xC2, 'O', "Ó"}, {0xC2, 'U', "Ú"},
        {0xC2, 'a', "á"}, {0xC2, 'e', "é"}, {0xC2, 'i', "í"}, {0xC2, 'o', "ó"}, {0xC2, 'u', "ú"},
        {0xC3, 'A', "Â"}, {0xC3, 'E', "Ê"}, {0xC3, 'I', "Î"}, {0xC3, 'O', "Ô"}, {0xC3, 'U', "Û"},
        {0xC3, 'a', "â"}, {0xC3, 'e', "ê"}, {0xC3, 'i', "î"}, {0xC3, 'o', "ô"}, {0xC3, 'u', "û"},
        {0xC4, 'A', "Ä"}, {0xC4, 'E', "Ë"}, {0xC4, 'I', "Ï"}, {0xC4, 'O', "Ö"}, {0xC4, 'U', "Ü"},
        {0xC4, 'a', "ä"}, {0xC4, 'e', "ë"}, {0xC4, 'i', "ï"}, {0xC4, 'o', "ö"}, {0xC4, 'u', "ü"},
        {0xC5, 'A', "Å"}, {0xC5, 'U', "Ů"},
        {0xC5, 'a', "å"}, {0xC5, 'u', "ů"},
        {0xC6, 'C', "Ç"}, {0xC6, 'G', "Ģ"}, {0xC6, 'K', "Ķ"}, {0xC6, 'L', "Ļ"}, {0xC6, 'N', "Ņ"},
        {0xC6, 'c', "ç"}, {0xC6, 'g', "ģ"}, {0xC6, 'k', "ķ"}, {0xC6, 'l', "ļ"}, {0xC6, 'n', "ņ"},
        {0xC7, 'N', "Ñ"}, {0xC7, 'C', "Ć"},
        {0xC7, 'n', "ñ"}, {0xC7, 'c', "ć"},
        {0xC8, 'O', "Ø"}, {0xC8, 'a', "å"}, {0xC8, 'u', "ů"},
        {0xC8, 'o', "ø"}, {0xC8, 'u', "ů"},
    };

    for (size_t i = 0; i < sizeof(mappings) / sizeof(DiacriticMapping); i++) {
        if (mappings[i].diacritic == diacritic && mappings[i].base == base) {
            return mappings[i].utf8;
        }
    }
    return NULL;
}

static char* convert_iso6937_to_utf8(const unsigned char *input, size_t length) {
    size_t out_len = length * 4;
    char *output = malloc(out_len);
    if (!output) return NULL;

    size_t j = 0;
    for (size_t i = 0; i < length; i++) {
        unsigned char diacritic = input[i];
        if (diacritic >= 0xC1 && diacritic <= 0xCF) {
            if (i + 1 < length) {
                const char* utf8_char = map_iso6937_to_utf8(diacritic, input[i + 1]);
                if (utf8_char) {
                    strcpy(&output[j], utf8_char);
                    j += strlen(utf8_char);
                    i++;
                    continue;
                }
            }
        }
        output[j++] = input[i];
    }

    output[j] = '\0';
    return output;
}

#include "libavcodec/ass.h"

// Extract text and colors from TTI block
bool extract_colors_from_tti(const uint8_t *buf, uint8_t *text_color, uint8_t *background_color, int line_count);
bool extract_colors_from_tti(const uint8_t *buf, uint8_t *text_color, uint8_t *background_color, int line_count) {
    *text_color = 0x00;  // Default to white
    *background_color = 0x07;  // Default to black
    int current_line = 0;  // Start at the first line

    for (int i = TTI_TEXT_FIELD_OFFSET; i < TTI_TEXT_FIELD_OFFSET + TTI_TEXT_FIELD_LENGTH; ++i) {
        uint8_t byte = buf[i];

        // If we encounter a 0x8A byte, we move to the next line
        if (byte == 0x8A) {
            current_line++;
            av_log(NULL, AV_LOG_INFO, "New line detected at offset %d (line %d)\n", i, current_line);

            // If we've reached the desired line, we stop
            if (current_line > line_count) {
                av_log(NULL, AV_LOG_INFO, "Line %d detected, stopping color search\n", line_count);
                break;
            }

            // Reset colors for the new line
            *text_color = 0x00;
            *background_color = 0x07;
        }

        // Only apply colors if we're on the correct line
        if (current_line == line_count) {
            if (byte >= 0x00 && byte <= 0x07) {
                *text_color = byte;

                // Log the text color found and its offset
                av_log(NULL, AV_LOG_INFO, "Text color found at offset %d: 0x%02X (%s)\n", i, byte,
                       byte == 0x00 ? "White" :
                       byte == 0x01 ? "Red" :
                       byte == 0x02 ? "Green" :
                       byte == 0x03 ? "Yellow" :
                       byte == 0x04 ? "Blue" :
                       byte == 0x05 ? "Magenta" :
                       byte == 0x06 ? "Cyan" :
                       byte == 0x07 ? "Black" : "Unknown");
            } else if (byte >= 0x10 && byte <= 0x17) {
                *background_color = byte & 0x07;

                // Log the background color found and its offset
                av_log(NULL, AV_LOG_INFO, "Background color found at offset %d: 0x%02X (%s)\n", i, byte,
                       (*background_color == 0x00) ? "White" :
                       (*background_color == 0x01) ? "Yellow" :
                       (*background_color == 0x02) ? "Green" :
                       (*background_color == 0x03) ? "Blue" :
                       (*background_color == 0x04) ? "Red" :
                       (*background_color == 0x05) ? "Magenta" :
                       (*background_color == 0x06) ? "Cyan" :
                       (*background_color == 0x07) ? "Black" : "Unknown");
            }
        }

    }

    return true;
}

// Function to extract text and colors from TTI block and return an ASS formatted string
static char *extract_text_and_colors_from_tti_block(const uint8_t *tti_block, int tti_block_size) {
    int text_field_offset = 13;
    char *ass_string = NULL;
    int i, text_len = 0;
    char line[tti_block_size * 2];
    int last_was_newline = 0;
    int line_count = 0;  // Line counter

    uint8_t text_color, background_color;
    extract_colors_from_tti(tti_block, &text_color, &background_color, line_count);

    char *text_color_str = NULL;
    if (text_color == 0) {
        text_color_str = "{\\c&HFFFFFF&}"; // White
    } else if (text_color == 1) {
        text_color_str = "{\\c&HFF0000&}"; // Blue (BGR: FF0000)
    } else if (text_color == 2) {
        text_color_str = "{\\c&H00FF00&}"; // Green (BGR: 00FF00)
    } else if (text_color == 3) {
        text_color_str = "{\\c&H00FFFF&}"; // Yellow (BGR: 00FFFF)
    } else if (text_color == 4) {
        text_color_str = "{\\c&H0000FF&}"; // Red (BGR: 0000FF)
    } else if (text_color == 5) {
        text_color_str = "{\\c&HFF00FF&}"; // Magenta (BGR: FF00FF)
    } else if (text_color == 6) {
        text_color_str = "{\\c&HFFFF00&}"; // Cyan (BGR: FFFF00)
    } else if (text_color == 7) {
        text_color_str = "{\\c&H000000&}"; // Black
    }

    char *border_color = NULL;
    if (background_color == 0) {
        border_color = "{\\3c&HFFFFFF&}"; // White
    } else if (background_color == 1) {
        border_color = "{\\3c&H00FFFF&}"; // Yellow (BGR: 00FFFF)
    } else if (background_color == 2) {
        border_color = "{\\3c&H00FF00&}"; // Green (BGR: 00FF00)
    } else if (background_color == 3) {
        border_color = "{\\3c&HFF0000&}"; // Blue (BGR: FF0000)
    } else if (background_color == 4) {
        border_color = "{\\3c&H0000FF&}"; // Red (BGR: 0000FF)
    } else if (background_color == 5) {
        border_color = "{\\3c&HFF00FF&}"; // Magenta (BGR: FF00FF)
    } else if (background_color == 6) {
        border_color = "{\\3c&HFFFF00&}"; // Cyan (BGR: FFFF00)
    } else if (background_color == 7) {
        border_color = "{\\3c&H000000&}"; // Black
    }

    ass_string = av_asprintf("%s%s", text_color_str, border_color); // Initialize with color

    for (i = text_field_offset; i < tti_block_size; i++) {
        uint8_t character = tti_block[i];

        if (character == 0x8A) { // New line
            line[text_len] = '\0'; // Terminate the line
            if (line_count > 0 && text_len > 0) {
                ass_string = av_asprintf("%s\\N%s", ass_string, line); // Add newline before the new line if it is not empty
            } else if (text_len > 0) {
                ass_string = av_asprintf("%s%s", ass_string, line); // Add first line without newline if it is not empty
            }
            line_count++; // Increment line counter

            text_len = 0; // Reset the counter for the next line

            // Extract colors for the next line
            extract_colors_from_tti(tti_block, &text_color, &background_color, line_count);

            if (text_color == 0) {
                text_color_str = "{\\c&HFFFFFF&}"; // White
            } else if (text_color == 1) {
                text_color_str = "{\\c&HFF0000&}"; // Blue (BGR: FF0000)
            } else if (text_color == 2) {
                text_color_str = "{\\c&H00FF00&}"; // Green (BGR: 00FF00)
            } else if (text_color == 3) {
                text_color_str = "{\\c&H00FFFF&}"; // Yellow (BGR: 00FFFF)
            } else if (text_color == 4) {
                text_color_str = "{\\c&H0000FF&}"; // Red (BGR: 0000FF)
            } else if (text_color == 5) {
                text_color_str = "{\\c&HFF00FF&}"; // Magenta (BGR: FF00FF)
            } else if (text_color == 6) {
                text_color_str = "{\\c&HFFFF00&}"; // Cyan (BGR: FFFF00)
            } else if (text_color == 7) {
                text_color_str = "{\\c&H000000&}"; // Black
            }

            if (background_color == 0) {
                border_color = "{\\3c&HFFFFFF&}"; // White
            } else if (background_color == 1) {
                border_color = "{\\3c&H00FFFF&}"; // Yellow (BGR: 00FFFF)
            } else if (background_color == 2) {
                border_color = "{\\3c&H00FF00&}"; // Green (BGR: 00FF00)
            } else if (background_color == 3) {
                border_color = "{\\3c&HFF0000&}"; // Blue (BGR: FF0000)
            } else if (background_color == 4) {
                border_color = "{\\3c&H0000FF&}"; // Red (BGR: 0000FF)
            } else if (background_color == 5) {
                border_color = "{\\3c&HFF00FF&}"; // Magenta (BGR: FF00FF)
            } else if (background_color == 6) {
                border_color = "{\\3c&HFFFF00&}"; // Cyan (BGR: FFFF00)
            } else if (background_color == 7) {
                border_color = "{\\3c&H000000&}"; // Black
            }

            ass_string = av_asprintf("%s%s%s", ass_string, text_color_str, border_color); // Add the new color
            continue;
        }

        if (character == 0x8F) {
            break; // End of text
        }

        if (character >= 32) {
            line[text_len++] = character; // Add characters to the line
        }
    }

    line[text_len] = '\0'; // Terminate the last line
    if (line_count > 0 && text_len > 0) {
        ass_string = av_asprintf("%s\\N%s", ass_string, line); // Add newline before the last line if it is not empty
    } else if (text_len > 0) {
        ass_string = av_asprintf("%s%s", ass_string, line); // Add the first line without newline if it is not empty
    }

    return ass_string;
}



static int ebustl_decode_frame(AVCodecContext *avctx, AVSubtitle *sub,
                               int *got_sub_ptr, const AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    FFASSDecoderContext *s = avctx->priv_data;
    *got_sub_ptr = 0;

    while (buf_size >= TTI_BLOCK_SIZE) {
        // Extract text and colors from the TTI block
        log_tti_block_hex(buf, TTI_BLOCK_SIZE);
        char *ass_text = extract_text_and_colors_from_tti_block(buf, TTI_BLOCK_SIZE);
        av_log(NULL, AV_LOG_DEBUG, "Extracted ASS text: %s\n", ass_text);

        // Ignore empty subtitles
        if (!ass_text || ass_text[0] == '\0') {
            av_freep(&ass_text);
            buf += TTI_BLOCK_SIZE;
            buf_size -= TTI_BLOCK_SIZE;
            continue;
        }

        // Handle text alignment
        uint8_t justification_code = buf[14];
        uint8_t vertical_position = buf[13];
        char *alignment_str = NULL;
        int horizontal_alignment = 2;  // Default to center alignment
        if (justification_code == 0x01) {
            horizontal_alignment = 1;  // Left alignment
        } else if (justification_code == 0x02) {
            horizontal_alignment = 2;  // Center alignment
        } else if (justification_code == 0x03) {
            horizontal_alignment = 3;  // Right alignment
        }

        int vertical_alignment = 2;  // Default to middle alignment
        if (vertical_position < 8) {
            vertical_alignment = 3;  // Bottom alignment
        } else if (vertical_position >= 8 && vertical_position <= 16) {
            vertical_alignment = 2;  // Middle alignment
        } else {
            vertical_alignment = 1;  // Top alignment
        }

        alignment_str = av_asprintf("{\\an%d}", (vertical_alignment - 1) * 3 + horizontal_alignment);

        // Build the final ASS string with color and alignment
        char *final_ass_text = av_asprintf("%s%s%s", alignment_str, ass_text, "{\\bord3}");

        // Add the subtitle to the ASS structure
        ff_ass_add_rect(sub, final_ass_text, s->readorder++, 0, NULL, NULL);

        sub->end_display_time = av_rescale_q(avpkt->duration, (AVRational){1, 1000}, avctx->time_base);

        av_freep(&ass_text);
        av_freep(&final_ass_text);
        av_freep(&alignment_str);

        buf += TTI_BLOCK_SIZE;
        buf_size -= TTI_BLOCK_SIZE;
    }

    if (s->readorder > 0) *got_sub_ptr = 1;

    return 0;
}

static av_cold int ebustl_decode_close(AVCodecContext *avctx)
{
    EbuStlContext *ctx = avctx->priv_data;
    return 0;
}

const FFCodec ff_ebustl_decoder = {
    .p.name           = "ebustl",
    CODEC_LONG_NAME("EBU STL Subtitle"),
    .p.type           = AVMEDIA_TYPE_SUBTITLE,
    .p.id             = AV_CODEC_ID_EBUSTL,
    .init             = ebustl_decode_init,
    FF_CODEC_DECODE_SUB_CB(ebustl_decode_frame),
    .close            = ebustl_decode_close,
    .priv_data_size   = sizeof(EbuStlContext),
};
